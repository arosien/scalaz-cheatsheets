\documentclass{tufte-handout}

%\geometry{showframe}% for debugging purposes -- displays the margins

\usepackage{amsmath}

% Set up the images/graphics package
\usepackage{graphicx}
\setkeys{Gin}{width=\linewidth,totalheight=\textheight,keepaspectratio}
\graphicspath{{graphics/}}

% The following package makes prettier tables.  We're all about the bling!
\usepackage{booktabs}

% The units package provides nice, non-stacked fractions and better spacing
% for units.
\usepackage{units}

% The fancyvrb package lets us customize the formatting of verbatim
% environments.  We use a slightly smaller font.
\usepackage{fancyvrb}
\fvset{fontsize=\normalsize}

% Small sections of multiple columns
\usepackage{multicol}

% Provides paragraphs of dummy text
\usepackage{lipsum}

\usepackage{multirow}

\newcommand{\fa}{\texttt{F[A]}}
\newcommand{\fb}{\texttt{F[B]}}
\newcommand{\rarr}{\texttt{=>}}

% These commands are used to pretty-print LaTeX commands
\newcommand{\doccmd}[1]{\texttt{\textbackslash#1}}% command name -- adds backslash automatically
\newcommand{\docopt}[1]{\ensuremath{\langle}\textrm{\textit{#1}}\ensuremath{\rangle}}% optional command argument
\newcommand{\docarg}[1]{\textrm{\textit{#1}}}% (required) command argument
\newenvironment{docspec}{\begin{quote}\noindent}{\end{quote}}% command specification environment
\newcommand{\docenv}[1]{\textsf{#1}}% environment name
\newcommand{\docpkg}[1]{\texttt{#1}}% package name
\newcommand{\doccls}[1]{\texttt{#1}}% document class name
\newcommand{\docclsopt}[1]{\texttt{#1}}% document class option name

\title{scalaz Cheat Sheet}
\author[Adam Rosien]{Adam Rosien (\href{mailto:adam@rosien.net}{adam@rosien.net})}
\date{2 December 2014}  % if the \date{} command is left out, the current date will be used

\begin{document}

\maketitle% this prints the handout title, author, and date

% TODO: hyperlinks to scalaz docs

\section{\texttt{* -> *} Typeclasses}\label{sec:sigs}

Kind \texttt{* -> *} is represented in Scala as a parameterized type with one "hole", i.e., \texttt{F[\_]}.

\begin{table}[ht]
  \centering
  \fontfamily{ppl}\selectfont
  \begin{tabular}{rcrlccl}
    Typeclass & Method & \multicolumn{5}{c}{Signature} \\
    \midrule
    Functor       & map & \fa & \rarr & \texttt{(A => B)} & \rarr & \fb \\
    Contravariant & contramap & \fa & \rarr & \texttt{(B => A)} & \rarr & \fb \\
    Apply         & ap & \fa & \rarr & \texttt{F[A => B]} & \rarr & \fb \\
    Bind          & flatMap & \fa & \rarr & \texttt{(A => F[B])} & \rarr & \fb \\
    Traverse      & traverse & \fa & \rarr & \texttt{(A => G[B])} & \rarr & \texttt{G[F[B]]} \\
    Foldable      & foldMap & \fa & \rarr & \texttt{(A => B)} & \rarr & \texttt{B} \\
    Plus          & plus & \fa & \rarr & \fa & \rarr & \fa \\
    Cobind        & cobind & \fa & \rarr & \texttt{(F[A] => B)} & \rarr & \fb \\
    Zip           & zip & \fa & \rarr & \fb & \rarr & \texttt{F[(A, B)]} \\
    Unzip         & unzip & \texttt{F[(A, B)]} & & &  \rarr & \texttt{(F[A], F[B])} \\
  \end{tabular}
  \label{tab:normaltab}
\end{table}


\begin{table}[ht]
  \centering
  \fontfamily{ppl}\selectfont
  \begin{tabular}{rrcclll}
    Typeclass & \multicolumn{5}{c}{Signature} & Method \\
    \midrule
    \multirow{8}{*}{Functor}
      & \textbf{\fa} & \textbf{\rarr} & \textbf{\texttt{(A => B)}} & \textbf{\rarr} & \textbf{\fb} & \textbf{map} \\
      & \fa & \rarr & \texttt{B} & \rarr & \fb & as \\
      & \fa & \rarr & & & \texttt{F[(A, A)]} & fpair \\
      & \fa & \rarr & \texttt{G[\_]} & \rarr & \texttt{F[G[A]]} & fpoint \\
      & \fa & \rarr & \texttt{(A => B)} & \rarr & \texttt{F[(A, B)]} & fproduct \\
      & \fa & \rarr & \texttt{B} & \rarr & \texttt{F[(B, A)]} & strengthL \\
      & \fa & \rarr & \texttt{B} & \rarr & \texttt{F[(A, B)]} & strengthR \\
      & \fa & \rarr & & & \texttt{F[Unit]} & void \\[.5cm]
    Contravariant & \fa & \rarr & \texttt{(B => A)} & \rarr & \fb & contramap \\[.5cm]
    \multirow{4}{*}{Apply} & \fa & \rarr & \texttt{F[A => B]} & \rarr & \fb & ap \\
                  & \fa & \rarr & \fb & \rarr & \texttt{F[(A,B)]} & tuple \\
                  & \fa & \rarr & \fb & \rarr & \fb & *> \\
                  & \fa & \rarr & \fb & \rarr & \fa & <* \\[.5cm]
    \multirow{5}{*}{Applicative} & \fa & \rarr & \texttt{F[A => B]} & \rarr & \fb & ap \\
                  & \fa & \rarr & \texttt{Boolean} & \rarr & \texttt{F[Unit]} & unlessM \\
                  & \fa & \rarr & \texttt{Boolean} & \rarr & \texttt{F[Unit]} & whenM \\
                  & \fa & \rarr & \texttt{Int} & \rarr & \texttt{F[List[A]]} & replicateM \\
                  & \fa & \rarr & \texttt{Int} & \rarr & \texttt{F[Unit]} & replicateM\_ \\[.5cm]
    \multirow{2}{*}{Bind} & \fa & \rarr & \texttt{(A => F[B])} & \rarr & \fb & flatMap \\
                  & \fa & \rarr & \fb & \rarr & \fb & \verb$>>$ \\[.5cm]
    \multirow{6}{*}{Traverse} & \fa & \rarr & \texttt{(A => G[B])} & \rarr & \texttt{G[F[B]]} & traverse \\
                  & \fa & \rarr & \texttt{(A => G[F[B]])} & \rarr & \texttt{G[F[B]]} & traverseM \\
                  & \fa & \rarr & & & \fa & reverse \\
                  & \fa & \rarr & \fb & \rarr & \texttt{F[(A, Option[B])]} & zipL \\
                  & \fa & \rarr & \fb & \rarr & \texttt{F[(Option[A], B)]} & zipR \\
%                  &          & \texttt{& F[B] => ((A, Option[B]) => C) => (List[B], F[C])} & zipWith \\
%                  &          & \texttt{& F[B] => ((A, Option[B]) => C) => F[C]} & zipWithL \\
%                  &          & \texttt{& F[B] => ((Option[A], B) => C) => F[C]} & zipWithR \\
%                  &          & \texttt{& S => ((S,A) => (S,B)) => (S, F[B])} & mapAccumL \\
%                  &          & \texttt{& S => ((S,A) => (S,B)) => (S, F[B])} & mapAccumR \\
%                  &          & \texttt{& S => (A => State[S, B]) => (S, F[B])} & runTraverseS \\
%                  &          & \texttt{& (A => State[S, B]) => State[S, F[B]]} & traverseS \\
%                  &          & \texttt{& (A => State[S, G[B]]) => State[S, G[F[B]]]} & traverseSTrampoline \\
%                  &          & \texttt{& (A => Kleisli[G, S, B]) => Kleisli[G, S, F[B]]} & traverseKTrampoline \\
                  & \texttt{F[G[A]]} & \rarr & & & \texttt{G[F[A]]} & sequence \\[.5cm]
    Foldable      & \fa & \rarr & \texttt{(A => B)} & \rarr & \texttt{B} & foldMap \\[.5cm]
    Plus          & \fa & \rarr & \fa & \rarr & \fa & plus \\[.5cm]
    Cobind        & \fa & \rarr & \texttt{(F[A] => B)} & \rarr & \fb & cobind \\[.5cm]
    Zip           & \fa & \rarr & \fb & \rarr & \texttt{F[(A, B)]} & zip \\[.5cm]
    Unzip         & \texttt{F[(A, B)]} & \rarr & & & \texttt{(F[A], F[B])} & unzip \\
  \end{tabular}
\end{table}


\section{Monads}\label{sec:monads}

\begin{table}[ht]
  \centering
  \fontfamily{ppl}\selectfont
  \begin{tabular}{rllll}
 %   \toprule
    Monad & Type & Effect\footnotemark[1] \\
    \midrule
    Identity & \texttt{Id[A]} & nothing \\
    List  & \texttt{List[A]}\footnotemark[2]          & arbitrary \# of results \\
    & \verb$IList[A]$ & \\
    Option & \texttt{Option[A]}\footnotemark[2]       & anonymous exception \\
    & \verb$Maybe[A]$ & optional values \\
    Either & \texttt{Either[A, B]}\footnotemark[2]        & exception \\
    & \verb$\/[A, B]$ & \\
    Reader & \texttt{Reader[E, A]}       & read environment value of type \verb$E$  \\
                 & & "dependency injection" \\
    Writer & \texttt{Writer[W, A]}        & append values of type \verb$W$ \\
              & & "logging" \\
    State & \texttt{State[S, A]}      & get/set state of type \verb$S$ \\
    IO  & \texttt{IO[A]}         & side-effect\footnotemark[3]  \\
%    \bottomrule
  \end{tabular}
  \label{tab:normaltab}
  %\zsavepos{pos:normaltab}
\end{table}

\footnotetext[1]{An \textit{effect} is \textbf{not} a \textit{side-effect}: the former is referentially-transparent while the latter is not.}

\footnotetext[2]{Defined in Scala itself, not in scalaz.}

\footnotetext[3]{Wait, how can a side-effect become just an effect?}


\section{Monad Transformers}\label{sec:monadtrans}

\begin{table}[ht]
  \centering
  \fontfamily{ppl}\selectfont
  \begin{tabular}{rllll}
  OptionT \\
  EitherT \\
  ReaderT \\
  WriterT \\
  StateT \\
  \end{tabular}
  \label{tab:normaltab}
  %\zsavepos{pos:normaltab}
\end{table}

\bibliography{sample-handout}
\bibliographystyle{plainnat}

\fancyfoot[C]{\copyright 2014 Adam S. Rosien (\href{mailto:adam@rosien.net}{\texttt{adam@rosien.net}}) \\ Source at \href{https://github.com/arosien/scalaz-base-talk-201208}{\texttt{https://github.com/arosien/scalaz-base-talk-201208}}}


\end{document}
